<title>Privacy Protection of IoT Based on Fully
Homomorphic Encryption</title>
<author>Wei-Tao Song  , Bin Hu, and Xiu-Feng Zhao</author>
<Affiliation>Information Science and Technology Institute, Zhengzhou 450001, China</Affiliation>
<year>2018</year>
<Jounral> Science and Technology of Nuclear Installation</Journal>
<Publishing_house>Hindawi</Publishing_house>
<Text_Collector>田苗，BFSU</Text_Collector>
<DOI>10.1155/2018/5787930</DOI>
<URL>https://doi.org/10.1155/2018/5787930</URL>
With the rapid development of Internet of Tings (IoT), grave questions of privacy protection are raised. Tis greatly impacts the large-scale applications of IoT. Fully homomorphic encryption (FHE) can provide privacy protection for IoT. But, its efciency needs to be greatly improved. Nowadays, Gentry’s bootstrapping technique is still the only known method of obtaining a “pure” FHE scheme. And it is also the key for the low efciency of FHE scheme due to the complexity homomorphic decryption. In this paper, the bootstrapping technique of Halevi and Shoup (EUROCRYPT 15) is improved. Firstly, by introducing a defnition of “load capacity”, we optimize the parameter range for which their bootstrapping technique works. Next we generalize their ciphertext modulus from closing to a power of two to more general situations. Tis enables the method to be applied in a larger number of situations. Moreover, this paper also shows how to introduce SIMD homomorphic computation techniques into the new method, to improve the efciency of recryption.
1. Introduction
Nowadays,   the   IoT   is   becoming   an   attractive   system paradigm  to  drive  a  substantive  leap  on  goods  and  ser- vices  through  physical,  cyber,  and  social  spaces.  It  covers from traditional equipment to general household equipment, whichbringmoreefciencyandconveniencetotheusersand change current ways of life greatly [1]. See Figure 1.
However,  the  application  of IoT  involves  mass  private information about users, such as healthcare, location, etc. For
the users, they want  service providers to process the  data accurately and efciently and extract the contained valuable information  with  keeping  user  data  unknown  by  others (including themselves).  All these problems  are  difcult to achieve by traditionally encryption schemes. Homomorphic encryption  technology  is  a  good  choice  to  solve  all  these problems [2, 3].
FHE permits  a worker to perform  arbitrarily complex programs on encrypted data without knowing the secret key [4]. And FHE has been the focus of extensive study [5–13], since the frst candidate scheme was introduced by Gentry [14]. But its efciency needs to be greatly improved.
Since bootstrapping technology is the essential technol- ogy  to  obtain  a  “pure”  FHE  at  present.  Meanwhile,  it  is also  the  main bottleneck  in  any practical  implementation due to the complexity homomorphic decryption. It is very meaningful to improve the efciency of bootstrapping, which mainly refers to fast low-circuit implementation of decryp- tion  function.  Without  loss  of generality,  the  decryption function for LWE- (Learning with Errors-) based FHE can be computed by evaluating some linear operation between ciphertext and secret key, then reducing the result modulo a  big  odd  modulus    and  then  reducing  the  result  mod- ulo  a  small  modulus   ,  to  get  the  plaintext   ,  namely,  = [[  ()] ] . For the decryption function, the modular- reduction operation of [[] ] (  ∈ Z) afects the depth of decryption circuit most.
Te past few years have seen an intensive study of boot- strapping technique. In the original bootstrapping technique of Gentry [14], he put forward an idea of “squash the decryp- tion circuit” to transform modular-reduction operation into summing operation. Tis got a moderate polynomial O(4 ) runtime. By proposed an amortized bootstrapping method, Brakerski, Gentry, and Vaikuntanathan (BGV) reduced the
Figure 1: IoT architecture.
runtime to O(2 ) [10].However,these resultsapplied only to “non-packed” ciphertexts (i.e., ones that encrypt just one bit each).
Gentry,  Halevi,  and  Smart  (GHS,  PKC2012)  reached  a major milestone of a bootstrapping algorithm concentrating on  the  BGV  ring-LWE-based  scheme  (ideal  lattice-based FHE) [15]. Tey proposed a simpler decryption formula. Tis is  done  by  choosing  a  prime  plaintext  modulus    and  a ciphertext modulus  close to a power of . Besides, they utilized  packed  ciphertexts  and  Fourier  Transform  to  aid efciency.  To  improve the  Fourier  Transform  step  of  [15], [16] presented a ring/feld switching technique. Tis obtained an asymptotically efcient bootstrapping method for BGV style SHE scheme. Orsini, Pol, and Smart (PKC15) proposed a bootstrapping BGV ciphertexts with a wider choice of  and , but their decryption formula was not simple as GHS’s work. Halevi and Shoup (HS, EUROCRYPT 15) generalized the plaintext modulus  in [17] to moregeneral situationsand got a better efciency by improving the bit-extraction way. Tis is asymptotically optimal space and time so far.
In another line of work, [18–22] present a bootstrapping technique for the GSW-FHE  [13] scheme. Tey get signif- cant progress in improving the bootstrapping technique on standard lattice-based FHE. And their progress mainly relies on the characteristic that noise in ciphertexts of GSW-FHE grows asymmetrically. Since compared with standard LWE- based FHE schemes, ring-LWE-based FHE schemes always have more efcient homomorphic operations. And among all the ring-LWE-based FHE schemes, BGV ring-LWE-based FHE scheme is optimal(note that GSW-FHE scheme is better than BGV-FHE scheme only in standard LWE-based FHE schemes).  Note  that,  in  this  paper,  the  aim  is  to  provide practical FHE scheme for the privacy protection of IoT. Tus, it concentrates on improving the bootstrapping technique of BGV ring-LWE-based FHE schemes in this paper.
Te  starting point  of this paper  is the  HS’s work  [17], where decryption procedure consists of a linear algebra step < ,  > and a modular reduction step [[] ] . When || ≤ 2 /4− and |[] | ≤ /4,modular reductionstep [[] ] can beconvertedtosimplebitoperations.Tisgreatlyreducesthe circuit depth of modular reduction. When homomorphically performedabovesimpledecryptionformula,thedeepestpart is homomorphic bit-extraction procedure, and its complexity
Wireless Communications and Mobile Computing
(both time and depth) increases with the most-signifcant extracted bit. In  [17], by adding to ciphertext multiples of   and  also  multiples  of  ,  they  proposed  a  lower-degree homomorphic bit-extraction procedure. And the bigger the parameter  range  of   for  the  simple  formula  of modular reduction,  the  better  the  performance  for  the  improved homomorphic bit-extraction procedure. See [17] for further details.
Contributions. In this paper, we optimize the parameters of bootstrapping algorithm proposed in EUROCRYPT 2015 by Halevi  and  Shoup.  Firstly,  by  introducing  a  defnition  of load capacity, we optimize the parameters range for which their bootstrapping technique works for the frst time. Next we generalize their  ciphertext modulus   to more general situations. Tis makes our method applicable to more cases. Moreover, we also show how to introduce SIMD technique into our new method, to improve the efciency of bootstrap- ping technique.
Organization.  Section 2  presents  the  notations  and  some background on the BGV cryptosystem. Section 3 optimizes the parameter range for which bootstrapping technique of Halevi  and  Shoup works. Next, the  ciphertext modulus  is generalized from closing to a power of two to more general
situations  in   Section  4.  Moreover,  it   also   shows  how  to
introduce SIMD homomorphic computation techniques into the new method to get an efcient bootstrapping method. And in Section 5, an implementation is made of BGV ring- LWE-based  scheme  based  on  our  efcient  bootstrapping method. Finally, Section 6concludes.
2. Preliminaries
Basic Notations. Set Z  ∈ (−/2,/2]⋂Z, and the notation [] is referred to as  mod  ,withcoefcientsbeing reduced into  the  range  (−/2,/2].  For  an  integer    (positive  or negative), we  consider the base-  representation  of   and denote its digits by ⟨0⟩ ,⟨1⟩ ,⋅⋅⋅ .
2.1. Homomorphic Encryption Schemes.  Let Mbe the message space  and  C  be  the  ciphertext  space.  A  homomorphic encryption  scheme     =   {,,, V} is  as follows:
(i) (1 ):outputpublickey ,secretkey  ,and evaluation key V .
(ii)  ():  output  ciphertext      ∈   C encrypted  by plaintext  ∈ M with public key  .
(iii)  ():recoverthemessageencryptedinthecipher- text  by secret key  .
(iv) VV (,1 ,..., ): output ciphertext   ∈ C which is obtained by applying evaluation key V and the function : M → M to 1 ,..., .
Suppose that ( 1 , 1 ) and (2 ,2 ) are two key-pairs of scheme . Let  be a ciphertext of plaintext  under  . Let 1 be a ciphertext of the  -thbitof thefrstsecretkey  1
under the second public key 2 .  is a decryption circuit. See Algorithm 1for the “Bootstrapping” algorithm.
It can be found that .(2 ,  ) = .( 1 ,) =  only when scheme  can compactly evaluate its decryp- tion  circuit.  However,  most  of  the  existing  schemes  do not  satisfy  this  condition  naturally.  It  needs  some  extra operations, such as “squashing the decryption circuit”, which causethelowefciencyofFHE.Tus,itisverymeaningfulfor lower-depth circuit implementation of decryption function.
3. Analysis of HS Recryption Procedure
We start by introducing the HS recryption procedure  [17] on  that  how  to  homomorphically  compute  the  modular-
reductionoperationina lower-depth circuit.Tespecifcs are in Lemma 1.
Lemma 1 (see [17]).  Let  > 1,  ≥ 1,  ≥ +2 and  =  +1 be integers, and also let  be an integer such that || ≤ 2 /4− and |[] | ≤ /4.
(i) If  is odd then [] =  <  − 1,⋅⋅⋅ ,0 > − <  +  − 1,⋅⋅⋅ , > (mod ).
(ii) If  = 2 then [] =  <  − 1,⋅⋅⋅ ,0 > − <  +  − 1,⋅⋅⋅ , > − <  − 1 > (mod2 ).
Lemma 1 transforms complex modular operations into simple bit operation, to get a lower-depth circuit of decryp- tionfunction.Butitisstillnoteasytoexecuteahomomorphic bit-extraction  operation.  Next,   [17]  proposed  a  fast  bit- extraction procedure. As stated in the former introduction, theperformanceoffastbit-extractionprocedureisdependent on the parameter range of  in Lemma 1. Tat is, the bigger parameter  range  of  ,  the  better  performance  of fast  bit- extraction  procedure.  Tus,  next  we  analyse  whether  the parameter range of  in Lemma 1 is optimal. In order to do so, we introduce a new concept called “load capacity”.
Defnition 2 (load capacity).  Let    ∈  Z+ ,    ∈  Z. Suppose the formula of modular reduction converted to simple bit operations works when −/2  <   ≤  []  ≤   ≤ /2, and  ≤  < . Ten the load capacity is defned by the product of twospanlengthsof  and [] ,namely, ( − ) × ( − ).
NextTeorem3presentsthegeneralrelationshipbetween the value  and  [] for the formula of modular reduction convertedtosimplebitoperations.
Teorem 3.  Let   > 1,   ≥ 1,   ≥  + 2 and   =  + 1 be integers, and also let  be an integer such that [] ∈ [,],and let  ⋅ (1 − ) ≤  < ( − 1) × ( − ).Ten
(i) if  is odd then [] =  <  − 1,⋅⋅⋅ ,0 > − <  +  − 1,⋅⋅⋅ , > (mod );
(ii) if  = 2 then [] =  <  − 1,⋅⋅⋅ ,0 > − <  +  − 1,⋅⋅⋅ , > − <  − 1 > (mod2 ).Algorithm 1: “Bootstrapping” algorithm.
Proof.  It starts with the odd- case. Let 0  = [] ∈ [,] and  = 0 +⋅ with  ∈ Z.Ten@1
@2
@3
@4
@5
@6
@7
Te proof for the   =  2 case is similar. Te details can be
referred to in the proof of [17]. It is omitted here.   Next we discuss how to choose the value of , in order to  obtain  the  maximum  “load  capacity”.  Load  capacity  is denoted by  ,then Figure 2: Te load capacity on the span length of  and  .
@8
Let  =  −  ,then  = (1 − ) ⋅ 2 +(−1)⋅.Teconcrete relations are as shown in Figure 2
It can be easily seen from Figure 2that the load capacity takes the maximum value when − = /2.Tat is,the load capacity for HS work is only related to the span length, not to the value of  and . Ten Corollary4 presents the optimal choice of [] and  for the formula of modular reduction convertedtosimplebitoperations.
Corollary 4.  Let   >  1,   ≥  1,   ≥  + 2,   =  + 1 and
∈ (−/2,0] be integers, and also let  be an integer such that
∈ Z,[] ∈ [,+/2],and⋅(1−) ≤  < (−1)×(/2−).
(i) If  is odd then [] =  <  − 1,⋅⋅⋅ ,0 > − <  +  − 1,⋅⋅⋅ , > (mod ).
(ii) If   = 2 then [] =  <  − 1,⋅⋅⋅ ,0 > − <  +  −
1,⋅⋅⋅ , > − <  − 1 > (mod2 ).                        Te conclusion is obvious; the proof is omitted here.
Note that, when    =  −/4, namely,  |[] |  ≤  /4, it is the same as HS’s work. But, the load capacity of this paper is bigger than that of HS’s work, since  of ours has a bigger span length, namely, || ≤ 2 /4 − /4. Te details are present
in Table 1.
AsseenfromTable1,comparedtoHS’work,itcanbeseen that our scheme has a better load capacity. Note that, while on the surface, it appears to obtain a tiny improvement in a nondominant term, i.e., where the load capacity of the choice in HS is 3 /4−2 ,thisisimprovedto 3 /4−2 /4,itisactually a meaningful job when you carefully analyse the principle of the trick of the fast bit-extraction procedure in [17]. Tat is, add to the coefcients of  multiples of  and  , making them divisible by   for some  ≤   <  without increasing them too much and also without increasing the noise too much. Tis means that bit-extraction can be implemented usingonlypolynomialsofdegreeatmost −  ,smallerthan  . Since the load capacity of this paper is 32 \4 bigger than that ofHS’swork,itmeansourworkallowsaddingmoremultiples of  and   to the coefcients of . Tat is, bit-extraction canbeimplementedusingpolynomials of lowerdegreetoget
a faster implementation. Besides, our variant of HS is more fexible and general on parameters.4. Generalize Modulus to More General Situations
In this section, it extends HS recryption procedure to have a wider choice of ciphertext modulus. Te specifcs are in Teorem 5.
Teorem 5.  Let  > 1,  ≥ 1,  ≥ +2,and  = ⋅ +V with , V ∈ Z and  ∈ [1, −1], V ∈ [1, −1],  ∤ , V,alsolet  be an integer such that [] ∈ [,],and@9
Ten,
(i) if  is odd then [] =  <  − 1,⋅⋅⋅ ,0 > −(((V <  − 1,⋅⋅⋅ ,0 >)×( < +−1,⋅⋅⋅ , >))/ < −1,⋅⋅⋅ ,0 > )(mod ),
1,⋅⋅⋅ ,0 >)×( < +−1,⋅⋅⋅ , >))/ < −1,⋅⋅⋅ ,0 >
here “× ”refers to scalar multiplication.
Proof. We begin with the odd- case. Let 0  = []  ∈ [,] and  = 0 +⋅ with  ∈ Z.Ten@10
Since  ≥  + 2,wecan getthat@11
Besides, since
@12
then
@13
And since −/2 ≤  ≤ 0  ≤  ≤ /2,then@14
Table 1: Te parameter of low-circuit implementation of modular reduction on HS and our work.
Algorithm 2: Bit-extraction (c,,,).
Tus, combined with formula (11), we can get that
@15
@16
Next we discuss how to choose the value of , in order to  obtain  the  maximum  “load  capacity”.  Load  capacity  is denoted by  ,then@17
Let  =  −  ,then、
@18
It is easy to get that  takes the maximum value when@19
Tat  is,  the load  capacity is  also  only related  to  the  span length, not to the value of  and  .
Ten Corollary 6presents the optimal choice of [] and  for the formula of modular reduction converted to simple bit operations.
Corollary 6.  Let   > 1,   ≥ 1,   ≥  + 2 and   =  ⋅  + V with , V ∈ Z and  ∈ [1, −1], V ∈ [1, −1],  ∤ , V,also let  be an integer such that [] ∈ [, + /2],and@20
Ten
(i) if  is odd then [] =  <  − 1,⋅⋅⋅ ,0 > −(((V <  − 1,⋅⋅⋅ ,0 >)×( < +−1,⋅⋅⋅ , >))/ < −1,⋅⋅⋅ ,0 > )(mod );
(ii) if   = 2 then []  =  <  − 1,⋅⋅⋅ ,0 > −((V <  −
Te conclusion is obvious; the proof is omitted here.
To  get  a  homomorphic  implementation  of the  simple decryption formula from above, frstly a homomorphic bit- extraction procedure  (Algorithm 2) is presented, which is slightly varied from the bit-extraction procedure of [17].
(c,) uses native homomorphic multiplication to multiply  by itself  times. To aid expo- sition,  this  code  assumes  that  the  modulus  and  secret key  remain  fxed;  otherwise  modulus-switching  and  key- switching should be added (and the level should be increased correspondingly to some  > 0).
Ten Algorithm 3shows how to combine our optimized “bootstrapping”  techniques  with  the  SIMD  homomorphic computation techniques of Smart-Vercauteren [23], to get a bootstrapping method that works in time quasilinear in the security parameter.
Algorithm 3: Batched bootstrapping implementation of our scheme.
Table 2: Experimental results for our batched bootstrapping and HS.
5. Implementation and Performance
In this section, an implementation of BGV ring-LWE-based scheme  is  made,  since  it  ofers  nearly  the  most  efcient homomorphic  operations.  Tis  scheme  is  defned  over  a
ring          Z[]/(Φ ()),  where  Φ ()  is  the    th cyclotomic polynomial. Let  be a prime or a prime power, and  A  ﬂ   Z []/Φ (). Specifcally, assume  Φ ()  ≡ 1 ()⋅⋅⋅ℓ ()(mod), where each   has the same degree  , which is equal to the order of  modulo  . Ten, by the Chinese Remainder Teorem, it has the isomorphism   ≅ ⨁ (Z[]/(, ()). Besides, suppose sk = (1, s) is the  - secret-key, where s ∈ Z[]/Φ () is an integer polynomial with small coefcients. sk   = (1, s  ) is the 0 -secret-key. c  = (0 ,1 ) is the  -ciphertext.
First,  several  groups  (,,) are  chosen  which  satisfy Φ ()  ≡ 1 ()⋅⋅⋅ℓ ()(mod). For each triple (,,), a test  is  run  separately based  on  our work and  HS’ work.
Tese tests were run on a four-year-old IBM System x3850 server, with two 64-bit 4-core Intel Xeon E5450 processors, and 35MB L2 cache and 32GB of RAM at 3.0 GHz. And the
implementation was mainly based on Shoup’s NTL library [23]version9.10.0andGNU’sGMPlibrary[24].Teformeris used for high-level numeric algorithms, and the latter is used for the underlying integer arithmetic operations. Besides, the code was compiled using the gcc compiler  (version 4.9.1). Table 2 summarizes the results from our experiments based
on our work and HS’.
Te  frst  column  gives  cyclotomic  ring  m  and  its  fac- torization into prime powers. Te second column gives the
plaintext space, i.e., the feld/ring that is embedded in each slot. Te third column gives the number of slots packed into a  single  ciphertext.  Te  fourth  column  gives  the  efective security level, computed using the formula that is used in HElib taken from  [15, Eqn. (8)]. Te total recrypt gives the total  time  for  a  single  recryption, while  the  previous  two rows  give  a  breakdown  of that  time  (note  that  the  time for the linear transforms includes some trivial preprocess- ing  time,  as  well  as  the  less  trivial  unpacking/repacking time).  Te last  two  rows  give the  memory used  (in  giga- bytes).
AsseenfromTable2,comparedtoHS’work,itcanbeeasy seen that the variant of HS has advantages both in efciency andinstoragespace.BesidesthevariantofHSismorefexible and general on parameters. Tis enables our method to be applied in a larger number of situations.
6. Conclusions
Up  to  now,  Gentry’s  bootstrapping  technique  is  still  the only  known  method  of obtaining  a  “pure”  FHE  scheme. Meanwhile it is also the key for the low efciency of FHE scheme. It is very meaningful to improve the efciency of bootstrapping,  which  mainly  refers  to  lower-depth  circuit implementation  of  decryption  function.  In  this  paper,  it improves  the  “load  capacity”  of HS’s  work  with  a  better efciency  for  bootstrapping  and  to  generalize    to  more general situations in a similar simple way. Tis enables our method to be applied in a larger number of situations, such as privacy protection of IoT.
Data Availability
Te  data  used  to  support  the  fndings  of this  study  are available from the corresponding author upon request.
Conflicts of Interest
Te  authors  declare  that  there  are  no  conficts  of interest
regarding the publication of this paper.
Acknowledgments
Tis  work  was  sponsored  in  part  by  the  National  Natu- ral  Science  Foundation  of  China  (Grants  nos.  61272041, 61202491,61272488,and61601515) andwas also supportedby the Foundation of Science and Technology on Information Assurance Laboratory (no. KJ-15-006).
